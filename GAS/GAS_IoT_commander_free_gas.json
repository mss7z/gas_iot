{"files":[{"id":"454c9296-5e18-49aa-948a-b668cfadf917","name":"appsscript","type":"json","source":"{\n  \"timeZone\": \"Asia/Tokyo\",\n  \"dependencies\": {},\n  \"exceptionLogging\": \"STACKDRIVER\",\n  \"runtimeVersion\": \"V8\",\n  \"webapp\": {\n    \"executeAs\": \"USER_DEPLOYING\",\n    \"access\": \"ANYONE_ANONYMOUS\"\n  }\n}"},{"id":"963f6ba4-719e-4ef2-83c9-dc539d7ceb10","name":"indexJS","type":"html","source":"\u003cscript\u003e\n\n/**\n * GASで実装したLongPollingに対するJSでのクライアント側実装 \n */\nclass LongPolling{\n  constructor(url){\n    this._url\u003durl;\n    this._status\u003d{version:0};\n    //Promiseによる非同期処理を用いて、setTimeoutにresolveを引数なしで呼び出すようにsetしてsleepを実現する\n    this._sleep \u003d (sleep_ms)\u003d\u003e{new Promise(resolve \u003d\u003e setTimeout(resolve,sleep_ms))};\n    /** 現行のtimeout時間 通信状態によってこれを調整する */\n    this._timeout_ms\u003d4000;\n  }\n  async fetchWithTimeout(options,timeout_ms){\n    /**\n     * timeoutを持つfetch apiの実装は次による\n     * https://github.com/node-fetch/node-fetch#request-cancellation-with-abortsignal\n     * 調べる限りAbortControllerを使用するのがスマート\n     * 日本語で調べるとリソースを食いつぶしかねないPromise.raceを用いた実装が、なぜかトップに出てくるので注意\n     */\n    console.log(`inFetchWithTimoout :${timeout_ms}`);\n    const controller \u003d new AbortController();\n    const timeout \u003d setTimeout(() \u003d\u003e {\n      controller.abort();\n    }, timeout_ms);\n    let data\u003dnull;\n    try {\n      await this._sleep(300);\n      const response \u003d await fetch(this._url, {\n        signal: controller.signal,\n        ...options\n      });\n      data \u003d await response.text();\n    } catch (error) {\n      if (error.name\u003d\u003d\u003d\"AbortError\") {\n        console.log(\u0027request was aborted\u0027);\n      }\n    } finally {\n      clearTimeout(timeout);\n    }\n    console.log(`received data: ${data}`);\n    return JSON.parse(data);\n  }\n  /**\n   * サーバから変更の通知があればstatusを返します。\n   * いずれかの原因でtimeoutしたときはnullを返します。\n   * @returns {(Object|null)}\n   */\n  async getChange(){\n    console.log(`timeout:${this._timeout_ms}ms`);\n    const tryTimeout_ms\u003dthis._timeout_ms;\n    const sendData\u003dJSON.stringify({\n      timeout:tryTimeout_ms,\n      version:this._status.version\n    });\n    const data\u003dawait this.fetchWithTimeout({\n      method:\"POST\",\n      headers:{\n        // CORSのPreflight requestをGASのサーバは処理しない。(OPTIONSメソッドに対応しない)\n        // よってPreflight requestが飛ばないようにするためにSimple Requestにする必要がある。\n        // Simple RequestにするためにContent-Typeの種類に気を付けること。\n        // https://developer.mozilla.org/ja/docs/Web/HTTP/CORS#%E5%8D%98%E7%B4%94%E3%83%AA%E3%82%AF%E3%82%A8%E3%82%B9%E3%83%88\n        \u0027Content-Type\u0027: \u0027text/plain\u0027,\n        // \u0027Content-Type\u0027: \u0027application/x-www-form-urlencoded\u0027\n        // \"Authorization\": `Bearer ${authToken}`,\n        // \u0027Accept\u0027: \u0027application/json\u0027,\n\n      },\n      body:sendData,\n    },tryTimeout_ms+2000); //サーバの処理時間と通信経路にかかる時間を考慮して2000ms追加\n    if(data\u003d\u003d\u003dnull){\n      //通信が外部から切断されたとき\n      if(this._timeout_ms\u003e1000){\n        this._timeout_ms-\u003d100;\n      }\n      return null;\n    }else{\n      //通信がサーバからresponseの返却により正常に終了したとき\n      this._timeout_ms+\u003d100;\n      if(data.ret\u003d\u003d\u003d\"change\"){\n        this._status\u003ddata[\"status\"];\n        return this._status;\n      }else{\n        return null;\n      }\n    }\n  }\n}\n\n\u003c/script\u003e"},{"id":"2692ee1f-8c04-4ea1-bdf4-0b6b3ccf6c26","name":"index","type":"html","source":"\u003c!DOCTYPE html\u003e\n\u003chtml\u003e\n  \u003chead\u003e\n    \u003cbase target\u003d\"_top\"\u003e\n    \u003c?!\u003d HtmlService.createHtmlOutputFromFile(\u0027indexJS\u0027).getContent(); ?\u003e\n    \u003cscript\u003e\n      const selfUrl\u003d\"\u003c?!\u003d ScriptApp.getService().getUrl() ?\u003e\";\n      (()\u003d\u003e{\n        console.log(\"helllllwllwlwlwlwlwlwlwlw??????????\");\n        // const authToken\u003d\"\u003c?\u003d ScriptApp.getOAuthToken() ?\u003e\";\n        console.log(selfUrl);\n        (async()\u003d\u003e{\n          const queryParams\u003dnew URLSearchParams({\n            type:\"polling\"\n          })\n          polling\u003dnew LongPolling(`${selfUrl}?${queryParams}`);\n          while(true){\n            const newStatus\u003dawait polling.getChange();\n            console.log(`newStatus:${newStatus}`);\n            if(newStatus!\u003d\u003dnull){\n              document.getElementById(\"statusBox\").textContent\u003dJSON.stringify(newStatus);\n              document.getElementById(\"temp\").textContent\u003d`温度:${newStatus.temp}℃`;\n              document.getElementById(\"humidity\").textContent\u003d`湿度:${newStatus.humidity}%`;\n              document.getElementById(\"time\").textContent\u003d`最終更新:${(new Date(newStatus.time)).toString()}`;\n\n            }\n          }\n        })();\n      })();\n      const updateStatus\u003dasync(sts)\u003d\u003e{\n        const queryParams\u003dnew URLSearchParams({\n          type:\"updateStatus\"\n        });\n        const response\u003dawait fetch(`${selfUrl}?${queryParams}`,{\n          method:\"POST\",\n          body: JSON.stringify(sts),\n          headers:{\n            \u0027Content-Type\u0027: \u0027text/plain\u0027,\n          }\n        });\n        console.log(response.text());\n      }\n    \u003c/script\u003e\n  \u003c/head\u003e\n  \u003cbody\u003e\n    \u003ch1\u003eHello???2a3\u003c/h1\u003e\n    \u003cinput type\u003d\"button\" onclick\u003d\"updateStatus({ledRequest:true})\" value\u003d\"ON\"\u003e\n    \u003cinput type\u003d\"button\" onclick\u003d\"updateStatus({ledRequest:false})\" value\u003d\"OFF\"\u003e\n    \u003cdiv id\u003d\"statusBox\"\u003e\u003c/div\u003e\n    \u003cdiv id\u003d\"temp\"\u003e-\u003c/div\u003e\n    \u003cdiv id\u003d\"humidity\"\u003e-\u003c/div\u003e\n    \u003cdiv id\u003d\"time\"\u003e-\u003c/div\u003e\n  \u003c/body\u003e\n\u003c/html\u003e\n"},{"id":"3d8ae477-09b5-43f5-871e-9b29d23e79e3","name":"parts","type":"server_js","source":"/**\n * JsonPropertyはGASのPropertiesServiceをクラスにまとめたものです。\n * 情報の読み書きをObjectで行い、内部でJSONに変換して文字列にしてPropertiesServiceに保存します。\n * PropertiesServiceのドキュメント\n * https://developers.google.com/apps-script/reference/properties/properties-service?hl\u003dja\n */\nclass JsonProperty{\n  constructor(keyName){\n    this._keyName\u003dkeyName;\n    this._proberty\u003dPropertiesService.getScriptProperties();\n  }\n  get isExistData(){\n    return null!\u003dthis.rawDataStr;\n  }\n  set rawDataStr(val){\n    // Logger.log(`hello called rawDataStr strval:${val}`);\n    this._proberty.setProperty(this._keyName,val);\n  }\n  get rawDataStr(){\n    Logger.log(`JsonProperty rawDataStr called warning`);\n    return this._proberty.getProperty(this._keyName);\n  }\n  set data(val){\n    this.rawDataStr\u003dJSON.stringify(val);\n    // Logger.log(`after data rawDataStr:${this.rawDataStr} val:${val[\"hel\"]}`);\n  }\n  get data(){\n    return JSON.parse(this.rawDataStr); \n  }\n};\n\nfunction testJsonProperty(){\n  const jp\u003dnew JsonProperty(\"testJsonProperty\");\n  Logger.log(`isExistData :${jp.isExistData}`);\n  jp.data\u003d{\"hel\":\"pro\"};\n  Logger.log(`append data`);\n  Logger.log(`isExistData :${jp.isExistData}`);\n  Logger.log(`rawdataStr :${jp.rawDataStr}`);\n  Logger.log(`data[hel] :${jp.data[\"hel\"]}`);\n}\n\n/**\n * JsonPropertyCacheはJsonPropertyにCache機能を追加したものです。\n * PropertiesServiceは読み書き回数に制限があります。\n * CacheServiceを用いることでPropertiesServiceの読み書き回数を削減することを目的としています。\n * \n * CacheServiceのドキュメント\n * https://developers.google.com/apps-script/reference/cache?hl\u003dja\n * CacheServiceとPropertiesServiceの比較は次のサイトの概要が分かりやすいです。\n * https://qiita.com/golyat/items/ba5d9ce38ec3308d3757\n */\nclass JsonPropertyCache{\n  constructor(keyName){\n    this._keyName\u003dkeyName;\n    this._jsonProperty\u003dnew JsonProperty(this._keyName);\n    this._cacheService\u003dCacheService.getScriptCache();\n    if(null\u003d\u003dthis._cacheService.get(this._keyName)){\n      this._loadFromJsonProperty();\n    }\n  }\n  _loadFromJsonProperty(){\n    this._cacheService.put(this._keyName,this._jsonProperty.rawDataStr);\n  }\n  get isExistData(){\n    const cacheRet\u003dthis._cacheService.get(this._keyName);\n    if (cacheRet\u003d\u003dnull){\n      return this._jsonProperty.isExistData;\n    }else{\n      return true;\n    }\n  }\n  set rawDataStr(val){\n    this._cacheService.put(this._keyName,val);\n    this._jsonProperty.rawDataStr\u003dval;\n  }\n  get rawDataStr(){\n    // Logger.log(`JsonPropertyCACHE rawDataStr called ok`);\n    const firstCacheRet\u003dthis._cacheService.get(this._keyName);\n    if(firstCacheRet\u003d\u003dnull){\n      this._loadFromJsonProperty();\n      return this._cacheService.get(this._keyName);\n    }else{\n      return firstCacheRet;\n    }\n  }\n  set data(val){\n    this.rawDataStr\u003dJSON.stringify(val);\n  }\n  get data(){\n    return JSON.parse(this.rawDataStr); \n  }\n}\nfunction testJsonPropertyCache(){\n  const jp\u003dnew JsonPropertyCache(\"testJsonProperty\");\n  Logger.log(`isExistData :${jp.isExistData}`);\n  jp.data\u003d{\"hel\":\"cache\"};\n  Logger.log(`append data`);\n  Logger.log(`isExistData :${jp.isExistData}`);\n  Logger.log(`rawdataStr :${jp.rawDataStr}`);\n  Logger.log(`data[hel] :${jp.data[\"hel\"]}`);\n}\n\n/**\n * StatusControlはこのシステム内で「Status」と呼ばれている状態を示すObjectを管理するためのものです。\n * JsonPropertyCacheを内部で使用します。\n */\nclass StatusControl{\n  /**\n   * StatusControlのインスタンスを作成します。\n   * @param {string} keyName - PropertiesServiceの中で使用するkeyです。\n   */\n  constructor(keyName){\n    this._keyName\u003dkeyName;\n    this._dataStore\u003dnew JsonPropertyCache(this._keyName);\n    if(!this._dataStore.isExistData){\n      this._dataStore.data\u003d{\n        \"version\":1,\n      };\n      Logger.log(`data reset`);\n    }\n    const mother\u003dthis;\n    /**\n     * this._WatcherはStatusの変更があるかを監視するクラスです。\n     * 親であるStatusControlをmotherでキャプチャーします。\n     */\n    this._Watcher\u003dclass{\n      /**\n       * @param {number} checkedVersion - 使用主が現在所有するStatusのversion\n       */\n      constructor(checkedVersion){\n        this._mother\u003dmother;\n        // this._checkedVersion\u003dthis._mother.version;\n        Logger.log(`watcher constructor checkedVersion:${checkedVersion}`);\n        this._checkedVersion\u003dcheckedVersion;\n      }\n      /**\n       * コンストラクタで申告のあったcheckedVersionより新しい場合はtrueを返します。\n       * @type {boolean}\n       */\n      get isChanged(){\n        const acquiredVer\u003dthis._mother.version;\n        const ret\u003d(acquiredVer!\u003dthis._checkedVersion);\n        this._checkedVersion\u003dacquiredVer;\n        return ret;\n      }\n    }\n  }\n  /**\n   * statusの差分アップデートをします。\n   * @param {Object} val - 変更のあったstatus \n   */\n  updateStatus(val){\n    const currentStatus\u003dthis.status;\n    // ...はスプレッド構文\n    const newStatus\u003d{\n      ...currentStatus,\n      ...val\n    }\n    return this.status\u003d(newStatus);\n  }\n  /**\n   * statusをセットすることでstatusを完全上書きします。\n   * @type {Object} \n   */\n  set status(val){\n    // Logger.log(\"called\");\n    val.version\u003dMath.trunc(this.version+1);\n    // Logger.log(`in status val:${val[\"hel\"]}`);\n    this._dataStore.data\u003dval;\n    return val;\n  }\n  /**\n   * 現行のstatus\n   * @type {Object} \n   */\n  get status(){\n    return this._dataStore.data;\n  }\n  /**\n   * @type {number} 現行のversion\n   */\n  get version(){\n    return Math.trunc(this.status[\"version\"]);\n  }\n  /**\n   * 新しいWatcherインスタンスを作成します。\n   * @return {this._Watcher} Watcherインスタンス\n   */\n  genWatcher(checkedVersion\u003d0){\n    return new this._Watcher(checkedVersion);\n  }\n};\n\nfunction testStatus(){\n  Logger.log(PropertiesService.getScriptProperties().getProperty(\"jax\"));\n  Logger.log(\"hellow\");\n  statusControl\u003dnew StatusControl(\"statusYtest\");\n  statusControl.status\u003d{\"hel\":\"hello\"};\n  Logger.log(statusControl.status);\n  const watcher\u003dstatusControl.genWatcher();\n  Logger.log(`isChanged ${watcher.isChanged}`);\n  Logger.log(`isChanged ${watcher.isChanged}`);\n  Logger.log(`isChanged ${watcher.isChanged}`);\n  statusControl.status\u003d{\"hel\":\"hello\"};\n  Logger.log(`isChanged ${watcher.isChanged}`);\n}"},{"id":"a5bc7f48-3db6-4e4e-97ba-586d7e935244","name":"main","type":"server_js","source":"statusCtrl\u003dnew StatusControl(\"statusX\");\n\nfunction onEdit(e){\n  //https://coporilife.com/392/\n  const sheetName \u003d e.source.getSheetName();\n  //編集されたシート名と対象にしたいシート名が一致したら実行\n  if(sheetName \u003d\u003d\u003d \u0027シート1\u0027){\n    //編集されたセルの行数を取得\n    const row \u003d e.range.getRow();\n    //編集されたセルの列数を取得\n    const col \u003d e.range.getColumn();\n\n    if(row \u003d\u003d\u003d 1 \u0026\u0026 col \u003d\u003d\u003d 1){\n      /**\n       * A1セルに変更があったらその値をstatusに反映する\n       * statusCtrlやLongPollingをテストする目的の機能\n       */\n      const sheet \u003d e.source.getActiveSheet();\n      const valCell\u003dsheet.getRange(1,1);\n      const contStatus\u003dNumber(valCell.getValue());\n      Logger.log(contStatus);\n      statusCtrl.updateStatus({\"cont\":contStatus});\n    }\n  }\n}\n\n//認証方法 -\u003e 時間がたつとOAuthTokenが変わるのでこの方法は不完全？\n//https://www.ka-net.org/blog/?p\u003d12258\n//CORSのエラー\n//https://stackoverflow.com/questions/53433938/how-do-i-allow-a-cors-requests-in-my-google-script\n//https://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q13276711733\n\nfunction doGet(e) {\n  const type\u003de.parameter.type;\n  Logger.log(\"detect get\");\n  switch(type){\n    /**\n     * ウェブアプリのhtmlを返す\n     * response ウェブアプリのhtml\n     */\n    default:\n    case undefined:\n    return HtmlService.createTemplateFromFile(\u0027index\u0027).evaluate();\n  }\n}\n\nfunction doPost(e) {\n  const type\u003de.parameter.type;\n  Logger.log(\"detect post\");\n  Logger.log(`request type: ${type}`);\n  switch(type){\n    /**\n     * Long Pollingを行う\n     * postData {\n     *  timeout_ms:タイムアウトするまでの時間,\n     *  version:post元が所有するstatusのversion\n     * }\n     * response {\n     *  ret:\"change\"|\"timeout\",\n     *  status:現行のstatus\n     * }\n     */\n    case \"polling\":{\n      const postJson\u003dJSON.parse(e.postData.getDataAsString());\n      const watcher\u003dstatusCtrl.genWatcher(postJson.version);\n      const timeoutTime\u003dDate.now()+postJson.timeout;\n      Logger.log(`receive postJson:${postJson}`);\n      Logger.log(`request timeout:${postJson.timeout} version:${postJson.version}`);\n      let retPayload\u003dnull;\n      while (true){\n        if(watcher.isChanged){\n          retPayload\u003d{\"ret\":\"change\",\"status\":statusCtrl.status};\n          break;\n        }else if((Date.now())\u003etimeoutTime){\n          retPayload\u003d{\"ret\":\"timeout\",\"status\":statusCtrl.status};\n          break;\n        }\n        Utilities.sleep(250);\n      }\n      const ret\u003dContentService.createTextOutput();\n      ret.setContent(JSON.stringify(retPayload));\n      ret.setMimeType(ContentService.MimeType.JSON);\n      return ret;\n    }\n    /** \n     * statusのupdateを行う\n     * postData statusの差分\n     * response 現行のstatus\n     */\n    case \"updateStatus\":{\n      const jsonString \u003d e.postData.getDataAsString();\n      const data \u003d JSON.parse(jsonString);\n      Logger.log(data);\n      statusCtrl.updateStatus(data);\n      const ret\u003dContentService.createTextOutput();\n      ret.setContent(JSON.stringify(statusCtrl.status));\n      ret.setMimeType(ContentService.MimeType.JSON);\n      return ret;\n    }\n    /**\n     * 温湿度計のSHT30のデータがpostされる\n     * statusの変更と、スプレッドシートへの書き込みを行う\n     * postData {\n     *  time: 温湿度が計測されたUNIX時間,\n     *  temp: 温度,\n     *  humidity: 湿度\n     * }\n     */\n    case \"postSHT30\":{\n      const jsonString \u003d e.postData.getDataAsString();\n      const data \u003d JSON.parse(jsonString);\n      Logger.log(data);\n      statusCtrl.updateStatus(data);\n      const ss \u003d SpreadsheetApp.getActiveSpreadsheet();\n      const sheet \u003d ss.getSheetByName(\"SHT30\");\n      sheet.appendRow([(new Date(data.time)).toString(),data.temp,data.humidity]);\n      return;\n    }\n  }\n  \n}\n\nfunction myFunction() {\n  // Logger.log(DriveApp.getRootFolder().getName());\n  Logger.log(ScriptApp.getOAuthToken());\n  // setJsonProperty(\"status\",{\"ver\":1});\n}"}]}